package com.logpresso.scanner;

import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;
import java.util.zip.ZipEntry;
import java.util.zip.ZipInputStream;

import com.logpresso.scanner.utils.IoUtils;

public class VersionClassifier {
	private static final char[] HEX_CODES = "0123456789abcdef".toCharArray();
	private static final Map<String, String> log4j1Digests;

	static {
		log4j1Digests = new HashMap<String, String>();
		log4j1Digests.put("906c9e0fd306e8b499b7f2dc84e2fef3", "1.1.3");
		log4j1Digests.put("37fa11f47f3b8d40882f8ee61b06e69f", "1.2.4");
		log4j1Digests.put("3f2f6a1ac893cb01c8f749036a1be514", "1.2.8");
		log4j1Digests.put("caea0074e17f5f84ee60804781f2f2a0", "1.2.9");
		log4j1Digests.put("d0b058288138bda4fccb504d4046e08c", "1.2.11");
		log4j1Digests.put("6bac921015bb8300d36df01d0bf1ceb4", "1.2.12");
		log4j1Digests.put("ff67193faa9007c0afc57dbc04c983bb", "1.2.15");
		log4j1Digests.put("bd5186a7747acdd133105873fbfefdb1", "1.2.16");

	}

	public static String classifyLog4j1Version(String categoryMd5, String mdcMd5, String ndcMd5) {
		if (categoryMd5 == null)
			return null;

		if (categoryMd5.equals("f1dda8732d825c58248e4c85f6bfff80")) {
			if (ndcMd5 == null)
				return null;

			if (ndcMd5.equals("1d79e7ecd65f4ec0560420024a8086f2"))
				return "1.2.13";
			else if (ndcMd5.equals("b5223239f2810943933b54d8ea681763"))
				return "1.2.14";
		} else if (categoryMd5.equals("ffbeb79ef0d29a902b84c8c06cac91ae")) {
			if (mdcMd5 == null)
				return null;

			if (mdcMd5.equals("cc556397bdabc4995892b18d2e6246f0")) {
				return "1.2.5";
			} else if (mdcMd5.equals("f74d8a96370d7776331dde8718a12990")) {
				return "1.2.6";
			} else if (mdcMd5.equals("8543bd826940dd588cd63b1118a82e90")) {
				return "1.2.7";
			}
		} else {
			return log4j1Digests.get(categoryMd5);
		}

		return null;
	}

	public static Map<String, String> generateSignature(File f) {
		Map<String, String> digests = new LinkedHashMap<String, String>();
		ZipInputStream zis = null;
		ZipEntry entry = null;
		try {
			zis = new ZipInputStream(new FileInputStream(f));
			while (true) {
				entry = zis.getNextEntry();
				if (entry == null)
					break;

				if (entry.getName().endsWith("/"))
					continue;

				String md5 = md5(zis);
				digests.put(entry.getName(), md5);
			}
			return digests;
		} catch (IOException e) {
			throw new IllegalStateException("cannot load zip entry " + entry, e);
		} finally {
			IoUtils.ensureClose(zis);
		}
	}

	public static String md5(InputStream is) {
		try {
			MessageDigest md5 = MessageDigest.getInstance("MD5");
			byte[] b = new byte[8192];
			while (true) {
				int len = is.read(b);
				if (len < 0)
					break;
				md5.update(b, 0, len);
			}

			return toHex(md5.digest());
		} catch (NoSuchAlgorithmException e) {
			throw new UnsupportedOperationException("md5 is not supported");
		} catch (IOException e) {
			throw new IllegalStateException("md5 error", e);
		}
	}

	private static String toHex(byte[] data) {
		char[] hex = new char[data.length * 2];
		for (int i = 0; i < data.length; i++) {
			hex[i * 2] = HEX_CODES[(data[i] >> 4) & 0xF];
			hex[i * 2 + 1] = HEX_CODES[data[i] & 0xF];
		}
		return new String(hex);
	}

	public static void main(String[] args) throws IOException {
		File[] files = new File(args[0]).listFiles();
		for (File f : files) {
			if (f.getName().endsWith(".sig"))
				continue;

			FileOutputStream fos = null;
			try {
				fos = new FileOutputStream(new File(f.getAbsolutePath() + ".sig"));
				Map<String, String> signatures = generateSignature(f);
				System.out.println(f.getAbsolutePath());

				for (String name : signatures.keySet()) {
					String md5 = signatures.get(name);
					String line = md5 + " " + name + "\n";
					System.out.print(line);

					fos.write(line.getBytes("utf-8"));
				}

				System.out.println("---");
			} finally {
				IoUtils.ensureClose(fos);
			}
		}
	}
}
