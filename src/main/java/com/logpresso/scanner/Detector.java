package com.logpresso.scanner;

import java.io.File;
import java.io.IOException;
import java.io.InputStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Enumeration;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;
import java.util.TreeMap;
import java.util.zip.ZipEntry;
import java.util.zip.ZipException;
import java.util.zip.ZipFile;
import java.util.zip.ZipInputStream;

import com.logpresso.scanner.Log4j2Scanner.Status;
import com.logpresso.scanner.utils.DummyInputStream;
import com.logpresso.scanner.utils.IoUtils;
import com.logpresso.scanner.utils.StringUtils;
import com.logpresso.scanner.utils.ZipUtils;

public class Detector {
	private static final String POTENTIALLY_VULNERABLE = "N/A - potentially vulnerable";
	private static final String JNDI_LOOKUP_CLASS_PATH = "org/apache/logging/log4j/core/lookup/JndiLookup.class";
	private static final String LOG4j_CORE_POM_PROPS = "META-INF/maven/org.apache.logging.log4j/log4j-core/pom.properties";

	private static final String LOG4J_12_CORE_POM_PROPS = "META-INF/maven/log4j/log4j/pom.properties";
	private static final String LOG4J_12_JMSAPPENDER = "org/apache/log4j/net/JMSAppender.class";

	// CVE-2021-42550 (published at 2021-12-16): vulnerable if version <= 1.2.7
	// logback 1.2.9 moved JNDIUtil.class to core package
	private static final String LOGBACK_CLASSIC_POM_PROPS = "META-INF/maven/ch.qos.logback/logback-classic/pom.properties";
	private static final String LOGBACK_JNDI_CLASS_PATH = "ch/qos/logback/classic/util/JNDIUtil.class";

	private Configuration config;

	// result
	private int vulnerableFileCount = 0;
	private int mitigatedFileCount = 0;
	private int potentiallyVulnerableFileCount = 0;
	private int errorCount = 0;
	private Set<File> vulnerableFiles = new LinkedHashSet<File>();

	// one archive file can be mapped to multiple entries
	private Map<File, List<ReportEntry>> fileReports = new TreeMap<File, List<ReportEntry>>();

	public Detector(Configuration config) {
		this.config = config;
	}

	public Map<File, List<ReportEntry>> getFileReports() {
		return fileReports;
	}

	public Set<String> getVulnerableEntries() {
		return new HashSet<String>(Arrays.asList(JNDI_LOOKUP_CLASS_PATH));
	}

	public int getVulnerableFileCount() {
		return vulnerableFileCount;
	}

	public int getMitigatedFileCount() {
		return mitigatedFileCount;
	}

	public int getPotentiallyVulnerableFileCount() {
		return potentiallyVulnerableFileCount;
	}

	public int getErrorCount() {
		return errorCount;
	}

	public Set<File> getVulnerableFiles() {
		return vulnerableFiles;
	}

	public List<ReportEntry> getReportEntries(File f) {
		return fileReports.get(f);
	}

	protected void scanJarFile(File jarFile, boolean fix) {
		ZipFile zipFile = null;
		InputStream is = null;
		boolean vulnerable = false;
		boolean mitigated = false;
		boolean potentiallyVulnerable = false;
		try {
			zipFile = new ZipFile(jarFile);

			Status log4j2Status = checkLog4j2Version(jarFile, fix, zipFile);
			vulnerable = (log4j2Status == Status.VULNERABLE);
			mitigated = (log4j2Status == Status.MITIGATED);
			potentiallyVulnerable = (log4j2Status == Status.POTENTIALLY_VULNERABLE);

			if (config.isScanForLog4j1()) {
				Status log4j1Status = checkLog4j1Version(jarFile, zipFile);
				potentiallyVulnerable |= (log4j1Status == Status.POTENTIALLY_VULNERABLE);
			}

			if (config.isScanForLogback()) {
				Status logbackStatus = checkLogbackVersion(jarFile, zipFile);
				potentiallyVulnerable |= (logbackStatus == Status.POTENTIALLY_VULNERABLE);
			}

			// scan nested jar files
			Enumeration<?> e = zipFile.entries();
			while (e.hasMoreElements()) {
				ZipEntry zipEntry = (ZipEntry) e.nextElement();
				if (!zipEntry.isDirectory() && ZipUtils.isScanTarget(zipEntry.getName(), config.isScanZip())) {
					Status nestedJarStatus = scanNestedJar(jarFile, zipFile, zipEntry);
					vulnerable |= (nestedJarStatus == Status.VULNERABLE);
					mitigated |= (nestedJarStatus == Status.MITIGATED);
					potentiallyVulnerable |= (nestedJarStatus == Status.POTENTIALLY_VULNERABLE);
				}
			}

			if (vulnerable)
				vulnerableFileCount++;
			else if (mitigated)
				mitigatedFileCount++;
			else if (potentiallyVulnerable)
				potentiallyVulnerableFileCount++;

			if (fix && vulnerable)
				vulnerableFiles.add(jarFile);

		} catch (ZipException e) {
			// ignore broken zip file
			System.out.printf("Skipping broken jar file %s ('%s')%n", jarFile, e.getMessage());
		} catch (IllegalArgumentException e) {
			if (e.getMessage().equals("MALFORMED")) {
				System.out.printf("Skipping broken jar file %s ('%s')%n", jarFile, e.getMessage());
			} else {
				System.out.printf("Scan error: '%s' on file: %s%n", e.getMessage(), jarFile);
				errorCount++;

				if (config.isDebug())
					e.printStackTrace();
			}
		} catch (Throwable t) {
			System.out.printf("Scan error: '%s' on file: %s%n", t.getMessage(), jarFile);
			errorCount++;

			if (config.isDebug())
				t.printStackTrace();
		} finally {
			IoUtils.ensureClose(is);
			ZipUtils.ensureClose(zipFile);
		}
	}

	protected Status checkLog4j2Version(File jarFile, boolean fix, ZipFile zipFile) throws IOException {
		ZipEntry entry = zipFile.getEntry(LOG4j_CORE_POM_PROPS);
		if (entry == null) {
			// Check for existence of JndiLookup.class; e.g. somebody repacked the entries
			// of the jars
			entry = zipFile.getEntry(JNDI_LOOKUP_CLASS_PATH);
			if (entry != null) {
				printDetectionForLog4j2(jarFile, null, POTENTIALLY_VULNERABLE, false, true);
				return Status.POTENTIALLY_VULNERABLE;
			}
			return Status.NOT_VULNERABLE;
		}

		InputStream is = null;
		try {
			is = zipFile.getInputStream(entry);

			String version = loadVulnerableLog4jVersion(is);
			if (version != null) {
				boolean mitigated = zipFile.getEntry(JNDI_LOOKUP_CLASS_PATH) == null;
				printDetectionForLog4j2(jarFile, null, version, mitigated, false);
				return mitigated ? Status.MITIGATED : Status.VULNERABLE;
			}

			return Status.NOT_VULNERABLE;
		} finally {
			IoUtils.ensureClose(is);
		}
	}

	private Status checkLog4j1Version(File jarFile, ZipFile zipFile) throws IOException {
		ZipEntry entry = zipFile.getEntry(LOG4J_12_CORE_POM_PROPS);
		if (entry == null) {
			entry = zipFile.getEntry(LOG4J_12_JMSAPPENDER);
			if (entry != null) {
				printDetectionForLog4j1(jarFile, null, POTENTIALLY_VULNERABLE);
				return Status.POTENTIALLY_VULNERABLE;
			}
			return Status.NOT_VULNERABLE;
		}

		InputStream is = null;
		try {
			is = zipFile.getInputStream(entry);

			String version = loadVulnerableLog4j1(is);
			if (version != null) {
				boolean jmsAppender = zipFile.getEntry(LOG4J_12_JMSAPPENDER) != null;
				if (jmsAppender)
					printDetectionForLog4j1(jarFile, null, version);

				return jmsAppender ? Status.POTENTIALLY_VULNERABLE : Status.NOT_VULNERABLE;
			}

			return Status.NOT_VULNERABLE;
		} finally {
			IoUtils.ensureClose(is);
		}
	}

	private Status checkLogbackVersion(File jarFile, ZipFile zipFile) throws IOException {
		ZipEntry entry = zipFile.getEntry(LOGBACK_CLASSIC_POM_PROPS);
		if (entry == null) {
			entry = zipFile.getEntry(LOGBACK_CLASSIC_POM_PROPS);
			if (entry != null) {
				printDetectionForLogback(jarFile, null, POTENTIALLY_VULNERABLE);
				return Status.POTENTIALLY_VULNERABLE;
			}
			return Status.NOT_VULNERABLE;
		}

		InputStream is = null;
		try {
			is = zipFile.getInputStream(entry);

			String version = loadVulnerableLogback(is);
			if (version != null) {
				boolean hasJndiUtil = zipFile.getEntry(LOGBACK_JNDI_CLASS_PATH) != null;
				if (hasJndiUtil)
					printDetectionForLogback(jarFile, null, version);

				return hasJndiUtil ? Status.POTENTIALLY_VULNERABLE : Status.NOT_VULNERABLE;
			}

			return Status.NOT_VULNERABLE;
		} finally {
			IoUtils.ensureClose(is);
		}
	}

	private void printDetectionForLog4j2(File jarFile, List<String> pathChain, String version, boolean mitigated,
			boolean potential) {
		String path = jarFile.getAbsolutePath();
		if (pathChain != null)
			path += " (" + StringUtils.toString(pathChain) + ")";

		String msg = potential ? "[?]" : "[*]";

		String cve = "CVE-2021-44228";
		if (version.startsWith("2.15."))
			cve = "CVE-2021-45046";

		msg += " Found " + cve + " (log4j 2.x) vulnerability in " + path + ", log4j " + version;
		if (mitigated)
			msg += " (mitigated)";

		System.out.println(msg);
		addReport(jarFile, pathChain, version, mitigated, potential);
	}

	private void printDetectionForLog4j1(File jarFile, List<String> pathChain, String version) {
		String path = jarFile.getAbsolutePath();
		if (pathChain != null)
			path += " (" + StringUtils.toString(pathChain) + ")";

		String msg = "[?] Found CVE-2021-4104  (log4j 1.2) vulnerability in " + path + ", log4j " + version;
		System.out.println(msg);

		addReport(jarFile, pathChain, version, false, true);
	}

	private void printDetectionForLogback(File jarFile, List<String> pathChain, String version) {
		String path = jarFile.getAbsolutePath();
		if (pathChain != null)
			path += " (" + StringUtils.toString(pathChain) + ")";

		String msg = "[?] Found CVE-2021-42550 (logback 1.2.7) vulnerability in " + path + ", logback " + version;
		System.out.println(msg);

		addReport(jarFile, pathChain, version, false, true);
	}

	private Status scanNestedJar(File fatJarFile, ZipFile zipFile, ZipEntry zipEntry) {
		InputStream is = null;
		try {
			is = zipFile.getInputStream(zipEntry);
			List<String> pathChain = new ArrayList<String>();
			pathChain.add(zipEntry.getName());
			Status status = scanStream(fatJarFile, is, pathChain);
			return status;
		} catch (IOException e) {
			String msg = "cannot scan nested jar " + fatJarFile.getAbsolutePath() + ", entry " + zipEntry.getName();
			throw new IllegalStateException(msg, e);
		} finally {
			IoUtils.ensureClose(is);
		}
	}

	private Status scanStream(File fatJarFile, InputStream is, List<String> pathChain) {
		ZipInputStream zis = null;
		Status maxNestedJarStatus = Status.NOT_VULNERABLE;
		String log4j2Version = null;
		String log4j1Version = null;
		String logbackVersion = null;

		boolean mitigated = true;
		boolean pomFound = false;

		// log4j1 class
		boolean foundJmsAppender = false;

		// logback class
		boolean foundJndiUtil = false;

		try {
			zis = new ZipInputStream(new DummyInputStream(is));

			while (true) {
				ZipEntry entry = zis.getNextEntry();
				if (entry == null)
					break;

				if (entry.getName().equals(LOG4j_CORE_POM_PROPS)) {
					log4j2Version = loadVulnerableLog4jVersion(zis);
					pomFound = true;
				}

				if (entry.getName().equals(JNDI_LOOKUP_CLASS_PATH)) {
					mitigated = false;
				}

				if (config.isScanForLog4j1()) {
					if (entry.getName().equals(LOG4J_12_CORE_POM_PROPS))
						log4j1Version = loadVulnerableLog4j1(zis);

					if (entry.getName().equals(LOG4J_12_JMSAPPENDER))
						foundJmsAppender = true;
				}

				if (config.isScanForLogback()) {
					if (entry.getName().equals(LOGBACK_CLASSIC_POM_PROPS))
						logbackVersion = loadVulnerableLogback(zis);

					if (entry.getName().equals(LOGBACK_JNDI_CLASS_PATH))
						foundJndiUtil = true;
				}

				if (ZipUtils.isScanTarget(entry.getName(), config.isScanZip())) {
					pathChain.add(entry.getName());
					Status nestedStatus = scanStream(fatJarFile, zis, pathChain);
					if (nestedStatus.ordinal() > maxNestedJarStatus.ordinal())
						maxNestedJarStatus = nestedStatus;

					pathChain.remove(pathChain.size() - 1);
				}
			}

			if (log4j2Version != null) {
				printDetectionForLog4j2(fatJarFile, pathChain, log4j2Version, mitigated, false);
				Status selfStatus = mitigated ? Status.MITIGATED : Status.VULNERABLE;
				return selfStatus.ordinal() > maxNestedJarStatus.ordinal() ? selfStatus : maxNestedJarStatus;
			}

			if (!mitigated && !pomFound) {
				printDetectionForLog4j2(fatJarFile, pathChain, POTENTIALLY_VULNERABLE, false, true);

				if (maxNestedJarStatus.ordinal() > Status.POTENTIALLY_VULNERABLE.ordinal())
					return maxNestedJarStatus;

				return Status.POTENTIALLY_VULNERABLE;
			}

			if (foundJmsAppender) {
				if (log4j1Version != null) {
					printDetectionForLog4j1(fatJarFile, pathChain, log4j1Version);
				} else {
					printDetectionForLog4j1(fatJarFile, pathChain, POTENTIALLY_VULNERABLE);
				}
				return Status.POTENTIALLY_VULNERABLE;
			}

			if (foundJndiUtil) {
				if (logbackVersion != null) {
					printDetectionForLogback(fatJarFile, pathChain, logbackVersion);
				} else {
					printDetectionForLogback(fatJarFile, pathChain, POTENTIALLY_VULNERABLE);
				}
				return Status.POTENTIALLY_VULNERABLE;
			}

			if (maxNestedJarStatus != Status.NOT_VULNERABLE)
				return maxNestedJarStatus;

			return Status.NOT_VULNERABLE;
		} catch (IOException e) {
			// ignore WinRAR
			String entryName = pathChain.get(pathChain.size() - 1);
			if (entryName.toLowerCase().endsWith(".rar"))
				return Status.NOT_VULNERABLE;

			String msg = "cannot scan nested jar " + fatJarFile.getAbsolutePath() + ", path " + StringUtils.toString(pathChain);
			throw new IllegalStateException(msg, e);
		} finally {
			IoUtils.ensureClose(zis);
		}
	}

	private String loadVulnerableLog4jVersion(InputStream is) throws IOException {
		Properties props = new Properties();
		props.load(is);

		String groupId = props.getProperty("groupId");
		String artifactId = props.getProperty("artifactId");
		String version = props.getProperty("version");

		if (groupId.equals("org.apache.logging.log4j") && artifactId.equals("log4j-core")) {
			Version v = Version.parse(version);
			if (isVulnerableLog4j2(v))
				return version;
		}

		return null;
	}

	private String loadVulnerableLog4j1(InputStream is) throws IOException {
		Properties props = new Properties();
		props.load(is);

		return props.getProperty("version");
	}

	private String loadVulnerableLogback(InputStream is) throws IOException {
		Properties props = new Properties();
		props.load(is);

		String groupId = props.getProperty("groupId");
		String artifactId = props.getProperty("artifactId");
		String version = props.getProperty("version");

		if (groupId.equals("ch.qos.logback") && artifactId.equals("logback-classic")) {
			Version v = Version.parse(version);
			if (isVulnerableLogback(v))
				return version;
		}

		return null;
	}

	private boolean isVulnerableLog4j2(Version v) {
		// treat 2.12.2 as non-vulnerable for JDK7
		if (v.getMajor() == 2 && v.getMinor() == 12 && v.getPatch() >= 2)
			return false;

		return v.getMajor() == 2 && v.getMinor() < 16;
	}

	private boolean isVulnerableLogback(Version v) {
		return (v.getMajor() == 1 && v.getMinor() == 2 && v.getPatch() <= 7) || (v.getMajor() == 1 && v.getMinor() <= 1)
				|| (v.getMajor() == 0 && v.getMinor() >= 9);
	}

	private void addReport(File jarFile, List<String> pathChain, String version, boolean mitigated, boolean potential) {
		List<ReportEntry> entries = fileReports.get(jarFile);
		if (entries == null) {
			entries = new ArrayList<ReportEntry>();
			fileReports.put(jarFile, entries);
		}

		Status status = Status.VULNERABLE;
		if (mitigated)
			status = Status.MITIGATED;
		else if (potential)
			status = Status.POTENTIALLY_VULNERABLE;

		ReportEntry entry = new ReportEntry(jarFile, StringUtils.toString(pathChain), version, status);
		entries.add(entry);
	}
}
